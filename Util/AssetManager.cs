using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

using RobloxFiles;
using Newtonsoft.Json;
using Source2Roblox.Forms;

using Microsoft.Win32;
using System.Threading;
using RobloxFiles.DataTypes;

namespace Source2Roblox.Upload
{
    public struct AssetUploadResponse
    {
        public bool Success;
        public string Message;

        public long? AssetId;
        public long? BackingAssetId;
    }

    public class AssetManager
    {
        private static readonly string ROBLOX_COOKIES = "";
        private string XsrfToken = "FETCH";

        private const string UploadDecal = "https://data.roblox.com/data/upload/json?assetTypeId=13&";
        private const string UploadMesh = "https://data.roblox.com/ide/publish/UploadNewMesh?";

        public readonly string RootDir;
        public readonly string RbxAssetDir;

        private readonly SemaphoreSlim UploadSemaphore = new SemaphoreSlim(1, 4);
        private readonly Dictionary<string, bool> UploadConsent = new Dictionary<string, bool>();

        static AssetManager()
        {
            // Fetch authentication cookies from Roblox Studio
            // so we can upload meshes and textures under their login.

            var robloxCookies = Registry.CurrentUser.GetSubKey
            (
                "SOFTWARE", "Roblox",
                "RobloxStudioBrowser",
                "roblox.com"
            );

            foreach (string name in robloxCookies.GetValueNames())
            {
                string cookie = robloxCookies.GetString(name);
                Match match = Regex.Match(cookie, "COOK::<([^>]*)>");

                if (match.Groups.Count > 1)
                {
                    cookie = match.Groups[1].Value;

                    if (!string.IsNullOrEmpty(ROBLOX_COOKIES))
                        ROBLOX_COOKIES += "; ";

                    ROBLOX_COOKIES += $"{name}={cookie}";
                }
            }
        }

        public AssetManager(string rootDir, string rbxAssetDir)
        {
            RootDir = rootDir;
            RbxAssetDir = rbxAssetDir;
        }

        public Func<Task<string>> BatchAssetId(string localPath)
        {
            if (localPath.EndsWith(".vtf"))
                localPath = localPath.Replace(".vtf", ".png");

            string filePath = Path.Combine(RootDir, localPath);
            byte[] content;

            if (File.Exists(filePath))
                content = File.ReadAllBytes(filePath);
            else
                content = Array.Empty<byte>();

            var info = new FileInfo(filePath);
            string dir = info.DirectoryName;

            string fileName = info.Name;
            string assetPath = filePath + ".asset";

            if (fileName.EndsWith(".mesh"))
            {
                if (fileName.StartsWith("cluster_") || fileName.StartsWith("disp_"))
                {
                    var assetHash = SharedString
                        .FromBuffer(content)
                        .ComputedKey
                        .Replace("+", "-")
                        .Replace("/", "_")
                        .TrimEnd('=');

                    string assetsDir = Path.Combine(dir, "assets");
                    assetPath = Path.Combine(assetsDir, assetHash + ".asset");

                    Directory.CreateDirectory(assetsDir);
                }
            }

            if (!File.Exists(assetPath) && !Program.LOCAL_ONLY)
            {
                if (!UploadConsent.TryGetValue(assetPath, out bool canUpload))
                {
                    var uploadForm = new Uploader(filePath);

                    if (!uploadForm.IsDisposed)
                        uploadForm.ShowDialog();

                    canUpload = uploadForm.Upload;
                    UploadConsent[assetPath] = canUpload;
                }

                if (canUpload)
                {
                    return () => Task.Run(async () =>
                    {
                        if (File.Exists(assetPath))
                        {
                            string assetId = File.ReadAllText(assetPath);
                            return $"rbxassetid://{assetId}";
                        }

                        var extension = info.Extension;
                        string name = info.Name.Replace(extension, "");
                        string endpoint = null;

                        if (extension == ".png")
                            endpoint = UploadDecal;
                        else if (extension == ".mesh")
                            endpoint = UploadMesh;

                        if (endpoint != null)
                        {
                            string uploadName = WebUtility.UrlEncode(name);
                            string uploadDesc = WebUtility.UrlEncode("Generated by Source2Roblox");

                            for (int retry = 0; retry < 5; retry++)
                            {
                                try
                                {
                                    string postUrl = $"{endpoint}name={uploadName}&description={uploadDesc}";
                                    var request = WebRequest.Create(postUrl) as HttpWebRequest;

                                    request.Method = "POST";
                                    request.ContentType = "*/*";
                                    request.UserAgent = "RobloxStudio/WinInet";

                                    request.Headers.Set("Cookie", ROBLOX_COOKIES);
                                    request.Headers.Set("X-CSRF-TOKEN", XsrfToken);

                                    using (var writeStream = request.GetRequestStream())
                                    {
                                        writeStream.Write(content, 0, content.Length);
                                        writeStream.Close();
                                    }

                                    var webResponse = request.GetResponse() as HttpWebResponse;

                                    using (var readStream = webResponse.GetResponseStream())
                                    using (var reader = new StreamReader(readStream))
                                    {
                                        string response = reader.ReadToEnd();
                                        string asset = response.ToString();

                                        if (!long.TryParse(response, out long assetId))
                                        {
                                            var upload = JsonConvert.DeserializeObject<AssetUploadResponse>(response);

                                            if (!upload.Success)
                                                throw new Exception(upload.Message);

                                            asset = upload.BackingAssetId.ToString();
                                        }

                                        File.WriteAllText(assetPath, asset);
                                        Console.WriteLine($"Uploaded {localPath}: {asset} -> {assetPath}");

                                        await Task.Delay(500);
                                        break;
                                    }
                                }
                                catch (Exception e)
                                {
                                    bool xsrf = false;

                                    if (e is WebException webEx)
                                    {
                                        var response = webEx.Response as HttpWebResponse;
                                        xsrf = response.StatusDescription.Contains("XSRF");

                                        if (xsrf)
                                            XsrfToken = response.Headers.Get("X-CSRF-TOKEN");

                                        response.Close();
                                    }

                                    if (xsrf)
                                        continue;

                                    Program.LogError(e.Message);

                                    if (!e.Message.ToLowerInvariant().Contains("inappropriate"))
                                    {
                                        Console.WriteLine("Cooling down from possible asset overload...");
                                        await Task.Delay(30000);
                                        continue;
                                    }

                                    uploadName = WebUtility.UrlEncode("[ Content Deleted ]");
                                }
                            }
                        }

                        if (File.Exists(assetPath))
                        {
                            string assetId = File.ReadAllText(assetPath);
                            return $"rbxassetid://{assetId}";
                        }

                        return $"{RbxAssetDir}/{localPath}";
                    });
                }
            }

            return () => Task.Run(() =>
            {
                if (File.Exists(assetPath) && !Program.LOCAL_ONLY)
                {
                    string assetId = File.ReadAllText(assetPath);
                    return $"rbxassetid://{assetId}";
                }

                return $"{RbxAssetDir}/{localPath}";
            });
        }

        public void BindAssetId(string localPath, List<Task> uploadPool, Instance target, string property)
        {
            Property prop = target.GetProperty(property);

            if (prop == null)
                throw new Exception($"Unknown property {property} in {target.ClassName}");

            // Prompt should be synchronously shown to user.
            var batchAssetId = BatchAssetId(localPath);

            // Hand off upload to asynchronous task.
            Task bind = Task.Run(async () =>
            {
                await UploadSemaphore.WaitAsync();
                var getAssetId = batchAssetId();

                string assetId = await getAssetId.ConfigureAwait(false);
                prop.Value = assetId;

                UploadSemaphore.Release();
            });

            // Add to the upload task pool.
            uploadPool.Add(bind);
        }
    }
}
